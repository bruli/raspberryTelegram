// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package app_test

import (
	"context"
	"github.com/bruli/rasberryTelegram/internal/app"
	"github.com/bruli/rasberryTelegram/internal/domain/log"
	"github.com/bruli/rasberryTelegram/internal/domain/status"
	"github.com/bruli/rasberryTelegram/internal/domain/weather"
	"sync"
)

// Ensure, that StatusRepositoryMock does implement app.StatusRepository.
// If this is not the case, regenerate this file with moq.
var _ app.StatusRepository = &StatusRepositoryMock{}

// StatusRepositoryMock is a mock implementation of app.StatusRepository.
//
//	func TestSomethingThatUsesStatusRepository(t *testing.T) {
//
//		// make and configure a mocked app.StatusRepository
//		mockedStatusRepository := &StatusRepositoryMock{
//			ActivateDeactivateFunc: func(ctx context.Context, activate bool) error {
//				panic("mock out the ActivateDeactivate method")
//			},
//			FindStatusFunc: func(ctx context.Context) (status.Status, error) {
//				panic("mock out the FindStatus method")
//			},
//		}
//
//		// use mockedStatusRepository in code that requires app.StatusRepository
//		// and then make assertions.
//
//	}
type StatusRepositoryMock struct {
	// ActivateDeactivateFunc mocks the ActivateDeactivate method.
	ActivateDeactivateFunc func(ctx context.Context, activate bool) error

	// FindStatusFunc mocks the FindStatus method.
	FindStatusFunc func(ctx context.Context) (status.Status, error)

	// calls tracks calls to the methods.
	calls struct {
		// ActivateDeactivate holds details about calls to the ActivateDeactivate method.
		ActivateDeactivate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Activate is the activate argument value.
			Activate bool
		}
		// FindStatus holds details about calls to the FindStatus method.
		FindStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockActivateDeactivate sync.RWMutex
	lockFindStatus         sync.RWMutex
}

// ActivateDeactivate calls ActivateDeactivateFunc.
func (mock *StatusRepositoryMock) ActivateDeactivate(ctx context.Context, activate bool) error {
	if mock.ActivateDeactivateFunc == nil {
		panic("StatusRepositoryMock.ActivateDeactivateFunc: method is nil but StatusRepository.ActivateDeactivate was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Activate bool
	}{
		Ctx:      ctx,
		Activate: activate,
	}
	mock.lockActivateDeactivate.Lock()
	mock.calls.ActivateDeactivate = append(mock.calls.ActivateDeactivate, callInfo)
	mock.lockActivateDeactivate.Unlock()
	return mock.ActivateDeactivateFunc(ctx, activate)
}

// ActivateDeactivateCalls gets all the calls that were made to ActivateDeactivate.
// Check the length with:
//
//	len(mockedStatusRepository.ActivateDeactivateCalls())
func (mock *StatusRepositoryMock) ActivateDeactivateCalls() []struct {
	Ctx      context.Context
	Activate bool
} {
	var calls []struct {
		Ctx      context.Context
		Activate bool
	}
	mock.lockActivateDeactivate.RLock()
	calls = mock.calls.ActivateDeactivate
	mock.lockActivateDeactivate.RUnlock()
	return calls
}

// FindStatus calls FindStatusFunc.
func (mock *StatusRepositoryMock) FindStatus(ctx context.Context) (status.Status, error) {
	if mock.FindStatusFunc == nil {
		panic("StatusRepositoryMock.FindStatusFunc: method is nil but StatusRepository.FindStatus was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFindStatus.Lock()
	mock.calls.FindStatus = append(mock.calls.FindStatus, callInfo)
	mock.lockFindStatus.Unlock()
	return mock.FindStatusFunc(ctx)
}

// FindStatusCalls gets all the calls that were made to FindStatus.
// Check the length with:
//
//	len(mockedStatusRepository.FindStatusCalls())
func (mock *StatusRepositoryMock) FindStatusCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFindStatus.RLock()
	calls = mock.calls.FindStatus
	mock.lockFindStatus.RUnlock()
	return calls
}

// Ensure, that WeatherRepositoryMock does implement app.WeatherRepository.
// If this is not the case, regenerate this file with moq.
var _ app.WeatherRepository = &WeatherRepositoryMock{}

// WeatherRepositoryMock is a mock implementation of app.WeatherRepository.
//
//	func TestSomethingThatUsesWeatherRepository(t *testing.T) {
//
//		// make and configure a mocked app.WeatherRepository
//		mockedWeatherRepository := &WeatherRepositoryMock{
//			FindWeatherFunc: func(ctx context.Context) (weather.Weather, error) {
//				panic("mock out the FindWeather method")
//			},
//		}
//
//		// use mockedWeatherRepository in code that requires app.WeatherRepository
//		// and then make assertions.
//
//	}
type WeatherRepositoryMock struct {
	// FindWeatherFunc mocks the FindWeather method.
	FindWeatherFunc func(ctx context.Context) (weather.Weather, error)

	// calls tracks calls to the methods.
	calls struct {
		// FindWeather holds details about calls to the FindWeather method.
		FindWeather []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockFindWeather sync.RWMutex
}

// FindWeather calls FindWeatherFunc.
func (mock *WeatherRepositoryMock) FindWeather(ctx context.Context) (weather.Weather, error) {
	if mock.FindWeatherFunc == nil {
		panic("WeatherRepositoryMock.FindWeatherFunc: method is nil but WeatherRepository.FindWeather was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFindWeather.Lock()
	mock.calls.FindWeather = append(mock.calls.FindWeather, callInfo)
	mock.lockFindWeather.Unlock()
	return mock.FindWeatherFunc(ctx)
}

// FindWeatherCalls gets all the calls that were made to FindWeather.
// Check the length with:
//
//	len(mockedWeatherRepository.FindWeatherCalls())
func (mock *WeatherRepositoryMock) FindWeatherCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFindWeather.RLock()
	calls = mock.calls.FindWeather
	mock.lockFindWeather.RUnlock()
	return calls
}

// Ensure, that LogsRepositoryMock does implement app.LogsRepository.
// If this is not the case, regenerate this file with moq.
var _ app.LogsRepository = &LogsRepositoryMock{}

// LogsRepositoryMock is a mock implementation of app.LogsRepository.
//
//	func TestSomethingThatUsesLogsRepository(t *testing.T) {
//
//		// make and configure a mocked app.LogsRepository
//		mockedLogsRepository := &LogsRepositoryMock{
//			FindLogsFunc: func(ctx context.Context, number int) ([]log.Log, error) {
//				panic("mock out the FindLogs method")
//			},
//		}
//
//		// use mockedLogsRepository in code that requires app.LogsRepository
//		// and then make assertions.
//
//	}
type LogsRepositoryMock struct {
	// FindLogsFunc mocks the FindLogs method.
	FindLogsFunc func(ctx context.Context, number int) ([]log.Log, error)

	// calls tracks calls to the methods.
	calls struct {
		// FindLogs holds details about calls to the FindLogs method.
		FindLogs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Number is the number argument value.
			Number int
		}
	}
	lockFindLogs sync.RWMutex
}

// FindLogs calls FindLogsFunc.
func (mock *LogsRepositoryMock) FindLogs(ctx context.Context, number int) ([]log.Log, error) {
	if mock.FindLogsFunc == nil {
		panic("LogsRepositoryMock.FindLogsFunc: method is nil but LogsRepository.FindLogs was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Number int
	}{
		Ctx:    ctx,
		Number: number,
	}
	mock.lockFindLogs.Lock()
	mock.calls.FindLogs = append(mock.calls.FindLogs, callInfo)
	mock.lockFindLogs.Unlock()
	return mock.FindLogsFunc(ctx, number)
}

// FindLogsCalls gets all the calls that were made to FindLogs.
// Check the length with:
//
//	len(mockedLogsRepository.FindLogsCalls())
func (mock *LogsRepositoryMock) FindLogsCalls() []struct {
	Ctx    context.Context
	Number int
} {
	var calls []struct {
		Ctx    context.Context
		Number int
	}
	mock.lockFindLogs.RLock()
	calls = mock.calls.FindLogs
	mock.lockFindLogs.RUnlock()
	return calls
}

// Ensure, that ExecutionRepositoryMock does implement app.ExecutionRepository.
// If this is not the case, regenerate this file with moq.
var _ app.ExecutionRepository = &ExecutionRepositoryMock{}

// ExecutionRepositoryMock is a mock implementation of app.ExecutionRepository.
//
//	func TestSomethingThatUsesExecutionRepository(t *testing.T) {
//
//		// make and configure a mocked app.ExecutionRepository
//		mockedExecutionRepository := &ExecutionRepositoryMock{
//			ExecuteZoneFunc: func(ctx context.Context, zone string, seconds int) error {
//				panic("mock out the ExecuteZone method")
//			},
//		}
//
//		// use mockedExecutionRepository in code that requires app.ExecutionRepository
//		// and then make assertions.
//
//	}
type ExecutionRepositoryMock struct {
	// ExecuteZoneFunc mocks the ExecuteZone method.
	ExecuteZoneFunc func(ctx context.Context, zone string, seconds int) error

	// calls tracks calls to the methods.
	calls struct {
		// ExecuteZone holds details about calls to the ExecuteZone method.
		ExecuteZone []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Zone is the zone argument value.
			Zone string
			// Seconds is the seconds argument value.
			Seconds int
		}
	}
	lockExecuteZone sync.RWMutex
}

// ExecuteZone calls ExecuteZoneFunc.
func (mock *ExecutionRepositoryMock) ExecuteZone(ctx context.Context, zone string, seconds int) error {
	if mock.ExecuteZoneFunc == nil {
		panic("ExecutionRepositoryMock.ExecuteZoneFunc: method is nil but ExecutionRepository.ExecuteZone was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Zone    string
		Seconds int
	}{
		Ctx:     ctx,
		Zone:    zone,
		Seconds: seconds,
	}
	mock.lockExecuteZone.Lock()
	mock.calls.ExecuteZone = append(mock.calls.ExecuteZone, callInfo)
	mock.lockExecuteZone.Unlock()
	return mock.ExecuteZoneFunc(ctx, zone, seconds)
}

// ExecuteZoneCalls gets all the calls that were made to ExecuteZone.
// Check the length with:
//
//	len(mockedExecutionRepository.ExecuteZoneCalls())
func (mock *ExecutionRepositoryMock) ExecuteZoneCalls() []struct {
	Ctx     context.Context
	Zone    string
	Seconds int
} {
	var calls []struct {
		Ctx     context.Context
		Zone    string
		Seconds int
	}
	mock.lockExecuteZone.RLock()
	calls = mock.calls.ExecuteZone
	mock.lockExecuteZone.RUnlock()
	return calls
}
